# 21.12.27

---

## 개념 정리 


<br/>

### 💡 데이터 전송 방식 

    * 데이터 전송 방식은 크게 두 가지로 나뉜다. 

        * 회선 교환 방식 

            - 데이터 전송에 전용 전송로를 점유하여 전달하며, 점유된 전송로는 다른 통신에서 사용할 수 없다.

            - 이동경로는 고정 , 데이터는 고정된 경로를 통해 연속적으로 전송된다.

            - 전송데이터의 순서와 수신데이터의 순서는 동일하다.

        * 패킷 교환 방식  

            - 데이터 전송로를 점유하지 않는다. (= 다양한 통신 주체들이 동일한 패킷 교환기를 사용할 수 있다는 의미)
            
            - 데이터 전송시 연속된 데이터가 아니라, 패킷이라는 분할된 단위로 전달한다.

            - 패킷 교환 방식은 두 가지로 나뉜다.

                * 가상 회선 패킷 교환 방식  
                    
                    - 고정된 이동 경로를 사용한다. 

                    - 전송데이터의 순서와 수신데이터의 순서는 동일하다.

                    - 고정된 이동경로를 만들어 데이터를 전송 한다는 점에서 회선 교환 방식의 특징을 가지고 있으나 전송로를 점유하지 않는다.

                    - TCP 프로토콜이 사용하는 데이터 전송방식이다. 

                * 데이터그램 패킷 교환 방식 

                    - 패킷마다 독립적인 이동 경로를 통해 데이터를 전송한다 (= 다른 패킷 교환기( 라우터)를 사용하여 라우팅 된다) 

                    - 전송데이터의 순서와 수신데이터의 순서는 동일하지 않다. (= 패킷마다 도착 순서가 다르기때문 )

                    - 속도는 빠르지만 신뢰성을 보장하지 않는다.

                    - UDP 프로토콜이 사용하는 데이터 전송방식이다. 

<br/>

### 💡 TCP 와 UDP

    * TCP 와 UDP모두 IP 프로토콜을 기반으로 구현된 전송계층에서 사용하는 프로토콜이지만 목적에 따라 서로 다른 특징을 가지고 있다.
      (서로 다른 특징 = 인터넷 프로토콜 한정 서로 다른 헤더 구조 )

    * TCP ( Transmission Control Protocol )

        - 패킷 교환 방식 프로토콜  : 가상 회선 패킷 교환 

        - 연결지향적 프로토콜 : 연결이란 데이터를 전송하기전 이동 통신 대상을 확인하고, 이동경롤를 구축하는 과정이라고 이해할 수 있다.

        - 고정된 데이터 통신 경로를 사용하여 데이터를 전송한다.

        - 신뢰성 있는 데이터 전송 서비스를 제공함. 오류 전송시 데이터를 재전송 하는 방식.

        - 데이터 경계를 구분하지 않는 바이트 스트림 서비스 

        - 1:1 통신인 unitcast 만 가능함

        - UDP에 비해서 속도가 느리다.


    * UDP ( User Datagram Protocol )

        - 패킷 교환 방식 프로토콜 : 데이터그램 패킷 교환 방식  

        - 비연결지향적 프로토콜 : 별도의 연결과정없이 바로 데이터를 전송한다.

        - 패킷마다 독립적인 이동경로를 통해서 데이터가 전송된다.

        - 비신뢰적 프로토콜 : UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출

        - 데이터 경계를 구분하는 데이터그램 서비스 

        - 1 대 1 통신(unicast) 1 대 다 통신(broadcast) 다 대 다 통신(multicast)


    * RUDP 

        - TCP의 장점은 신뢰성과, UDP의 장점은 속도를 모두 갖춘 Reliable UDP

        - TCP가 제공하는 순서 보장 도착 보장 무결성 보장을  UDP 통신에도 보장해주는 것 

        - 패킷에 번호를 붙이는 방법으로 순서보장도착보장 

        - 무결성은 checksum을 통해서 


<br/>

### 💡 TCP 프로토콜의 연결 수립과정  



    * HandShake 

        * TCP 프로토콜에서 통신 주체들의 통신을 위해서 연결 상태를 만들고 해제하는 과정을 의미한다. 연결을 수립하는 과정을 3-way Handshake, 해제하는 과정을 4-way Handshake이다.
           
        * 더해서  HandShake 개념또한 통신과정이라는 점에서 볼때, 연결 수립부터 해제까지 통신하는 과정을 2-way Handshake 라고 한다.

        * HandShake 는 TCP 헤더의 시퀀스 넘버, ACK 넘버, flag 값을 통해서 이루어진다. 송신측은 시퀀스 넘버를 통해서 전달하고, 수신측은 자신의 시퀀스 넘버와 송신측으로부터 받은 시퀀스 넘버에 받은 데이터의 크기 또는 1을 더해서 ack 넘버를 만든 뒤 통신이 잘 되었다는 상태를 말해준다.

        * 즉 각자 시퀀스 넘버를 만들고, 이를 기반으로한  ACK 넘버로 수신받았음을 알리며, flag 값을 통해서 알려준다.

        * Ack (=Acknowledgement) : 제대로 된 시퀀스 번호를 받았다는 확인의 의미인 승인 번호


        * 3-way Handshake

            * TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램(요청자) 이 데이터를 전송하기 전에 신뢰성 있는 서비스를 제공하기 위해  수신측 응용프로그램에게 사전에 연결을(=세션)을 수립하는 과정 (= 논리적 연결성립)

            * 과정 

                * 1   initiator  -> reciever  ( Syn  ) 

                    - 초기 연결요청시 요청자는 랜덤한 시퀀스 번호와 syn flag를 헤더에 담아 수신측에 보낸다
                    - 시퀀스 넘버를 임의의 수로 사용하는 이유는 보안상의 이유이다.

                * 2   initiator  <- reciever  ( Ack + Syn ) 

                    - reciever 측에서 생성한  시퀀스 넘버 +  승인 번호( = 처음 요청자가 보낸 시퀀스 번호 + 1 )  + ( syn + ack ) flag를 보냄 

                * 3  initiator -> reciever  ( Ack ) 

                    - 수신측으로 부터 받은 승인번호를  자신의 시퀀스 번호 + 1과 대조하여 연결이 제대로 성립되었는지 확인
                    
                    - 시퀀스 번호와 함께 승인번호 (상대방의 시퀀스 번호 + 1 ) 수신자에게 보내준다.

                * 해당 과정을 완료하면 두 대상은 ESTABLISHED 상태가 된다.  해당 상태가 되면 요청자와 수신자는 신뢰성 있는 연결이 생겼다고 판단한 뒤 본격적으로 통신을 시작한다.
           

        * 4-way Handshake

            * TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 연결을 종료하기 위해 하는 통신과정이다.( =양쪽이 연결을 종료할 준비가 되었는지 확인하는 과정 ) 
            
            * 특별한 규칙없이 연결을 종료할시 문제가 발생할 가능성이 높기때문에 연결 수립과정보다 중요하다.

            * 예시  : 일방적으로 연결을 끊음 --> 다른 한쪽에서 대답을 기다릴 수 있다 or 데이터 전송오류로 받지 못한 데이터를 다시 받을 수 없는 경우가 생긴다.


            * 3-way 처럼  순차적으로 주고받는 방식이 뿐만 아니라 상대방이 응답을 줄 때까지 대기하는 과정이 추가되기 때문에 엇나가면 서로 계속 대기만 하고 있는 데드락(Deadlock) 상황이 연출될 수도 있다.

            * 데드락 발생시 타임아웃이 되며 연결을 강제로 종료하거나 다음 단계로 넘어간다. 그래도 그 시간 동안 프로세스가 메모리와 포트를 점유하고 있으므로 트래픽이 많은 서버라면 이로 인해 병목이 발생할 가능성은 늘 있다.



            * 과정 

                * 1 initiator -> reciever (FIN)

                    - 요청자가 FIN flag를  수신자에게 보내면서 FIN_WAIT1 상태로 들어서게 된다.

                * 2 initiator <- reciever (ACK)

                    - FIN 패킷을 받은 수신자는 요청자에게  승인 번호와 ACK flag를  보낸 뒤 뒤 CLOSE_WAIT 상태로 들어간다.
	
                    - 이때 ACk 만 받은 요청자는 수신자의 데이터 처리가 끝나 종료함수를 호출하고 FIN flag를 보낼때까지 기다려야한다. 계속 대기 -> 타임아웃 ( 데드락 발생가능성 ) 
                
                    - 수신자가 요청자로부터 FIN flag을 받더라도, 데이터 처리가 완료되지 않을 수 있다. 따라서 완료한후 종료함수를 호출하고 다시 FIN 패킷을 보내는 것이다.                    

                * 3 initiator <- reciever (FIN)

                    - 종료하는 함수를 명시적으로 호출하고, 아까 요청자가 보냈던 연결 종료 요청에 합의한다는 의미로 요청자에게 다시 FIN 패킷을 보낸다.
                    
                * 4 initiator -> reciever (ACK)

                    - FIN을 받은 요청자는 ACK flag를 보낸 뒤 TIME_WAIT 상태로 들어가 일정시간 대기후 종료한다. (2 MSL)
                    
                    - TIME_WAIT의 역할은 수신자로부터 받을 수도 있는 데이터를 위해서 유지하는 것이다.
                    
                    - 예를 들어 수신측이 데이터를 전달 했지만 요청자가 종료되어 답해주지 않을 시 데드락에 빠진다.  



        * 2-way Handshake

            * TCP/IP 프로토콜을 사용하는 응용프르로그램들이 3-way Handshake를 통해 세션 연결을 세운 뒤 통신하는 과정을 의미한다.

            * 과정 

                * 1 sender  -> reciever  ( Syn ) 

                * 2 sender  <- reciever  ( Ack + Syn ) 


    * 관련 질문 정리 

        * 연결 종료시 3-way Handshake 대신 4-way Handshake를  사용하는 이유 

            - 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 먼저 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.


        * TIME-WAIT는 왜?
            
            - 서버에서 FIN을 전송하기 전에 클라이언트가 전송한 패킷이 라우팅 지연이나 패킷 유실로 인한 재전송 등으로 인해 해당 ACK 패킷이 FIN 패킷보다 늦게 도착하는 상황을 대비해야하기 때문이다

        *  3-way handshaking 과정에서 클라이언트가 서버가 보낸 ACK+SYN을 받지 못하면?

            -  Timeout이 되기 전까지 서버에게 ACK, SYN 세그먼트가 오지 않으면 클라이언트는 다시 SYN 세그먼트를 보내고 수신을 대기한다.

        * 4-way handshaking 과정에서 클라이언트가 마지막에 ACK를 굳이 보내는 이유?

            - ??

        * 만약 Server에서 FIN 세그먼트를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면 어떻게 될까?

            - 그래서 TIME-WAIT이 있는거 

        * 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?
        
            - ISN은 쉽게 예측되므로 보안에 취약함. 
            - 다른 사용자와 같은 포트를 사용하고 있을 때 패킷을 착각할 수 있는 경우가 생겨 난수로 ISN을 초기화 합니다. 







<br/>

### 💡 HTTP 와 HTTPS 

    1. HTTP 프로토콜의 기본적인 특징 

        * 인터넷에서 사용하는 TCP/IP 기반 응용 계층 프로토콜이다. 
        
        * 서버 클라이언트 모델을 사용한다.

            - 모든 통신 과정은 클라이언트의 요청과 서버의 응답으로 이루어짐 

            - 클라이언트란 자원을 요청하는 쪽, 서버는 자원을 제공하는 쪽 

            - 클라이언트는 http request 메세지를 통해 요청, 서버는 http response를 통해 응답 

        * Connectless 

            - HTTP는 요청과 응답이 끝나면 연결을 끊는다.

        * STATELESS

            - 클라이언트의 상태를 유지하지 못한다 . 비연경성의 특징에서 파생된 특성 


        * 장점

            - 연결상태를 유지한다면 연결을 위해 생성하는 소캣, 할당하는 포트 할당이 필요하다. 따라서 한정된 클라이언트의 요청만 처리할 수 있다.   
            그러나 비연결성을 유지함으로써 이러한 연결성의 단점을 해결하고 , 더 많은 클라이언트의 요청을 처리할 수 있다.
            
        * 단점 

            - 서버가 클라이언트의 상태를 기억하지 못한다. 연결할때 마다 새로운 연결이 된다. --> 이를 해결하기 위해  JWT, 세션, 쿠키 등의 방식이 생겨남  


    2. HTTP 프로토콜 구조

            
        * HTTP Request 구조


            *  start line
                - HTTP request의 첫 라인
                *  3부분으로 구성됨 
                    
                    - HTTP Method (해당 request가 의도한 action을 정의하는 부분)
                    - Request target ( 해당 request가 전송되는 목표 uri)
                    - HTTP Version  ( HTTP 버젼. 버젼에는 1.0, 1.1, 2.0)

            *  headers
                - request에 대한 추가 정보를 담고 있는 부분.
                - ex) request 메세지 body의 총 길이 (Content-Length) 
                - Key:Value 값으로 되어있다
                - 3부분 으로 구성되어 있다는것만 알자 

                Host : 요청이 전송되는 target의 host url: 예를 들어, google.com

                User-Agent : 요청을 보내는 클라이언트의 대한 정보: 예를 들어, 웹브라우저에 대한 정보.

                Accept : 해당 요청이 받을 수 있는 응답(response) 타입.

                Connection : 해당 요청이 끝난후에 클라이언트와 서버가 계속해서 네트워크 컨넥션을 유지 할것인지 아니면 끊을것인지에 대해 지시하는 부분.

                Content-Type : 해당 요청이 보내는 메세지 body의 타입. 예를 들어, JSON을 보내면 application/json.

                Content-Length: : 메세지 body의 길이.


            * body
                -해당 reqeust의 실제 메세지/내용.
                -Body가 없는 request도 많다. 예를 들어, GET request들은 대부분 body가 없음


            * HTTP 요청 메서드 ( 데이터를 요청하는데 요청하는 데이터에 대한 특정 동작수행을 요청)
                - GET : 존재하는 자원에 대한 요청
                - POST : 새로운 자원을 생성
                - PUT : 존재하는 자원에 대한 변경
                - DELETE : 존재하는 자원에 대한 삭제


            * 자주 쓰이는 HTTP Methods

                * GET :	
                    - 서버로부터 자원을 요청할때 사용하는 메서드 
                    - body를 사용하지 않고 데이터가 필요할시 헤더에 쿼리스트링 형태로 전달한다. 	
                    - URL에 데이터가 노출되어 보안에 취약하다
                    - 웹 캐싱이 가능한 메서드이다. (요청이므로)

                * POST : 
                    - 데이터를 생성 수정 삭제할떄 주로 사용함 
                    - 요청할때 필요한 데이터를 바디부분에 담에서 보낸다.
                    - URL에 데이터가 노출되지 않아서 기본 보안은 되어있다.
                    - 웹케싱이 불가능하다. 


                * 차이점 정리 
                     - 사용 목적 : Get은 서버의 리소스에서 데이터를 요청시, Post는 서버의 리소스를 새로 생성 OR 갱신 시 사용(Get은 Select, Post는 Create에 가깝다 생각하면 된다.)
                    
                    - 요청에 body 유무 : Get 은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 body가 존재하지 않는다. Post는 body에 데이터를 담아보내기 때문에 body가 존재한다.    
                    
                    - 웹 캐싱 : https://goddaehee.tistory.com/171

        * HTTP Response 구조


            * Status line
                - Response의 상태를 간략하게 나타내주는 부분.
                * 3부분으로 구성되어 있다.

                    - HTTP 버젼
                    - Status code: 응답 상태를 나타내는 코드. 숫자로 되어 있는 코드.
                    - Status text: 응답 상태를 간략하게 설명해주는 부분
                    

            * Headers
                - Response의 headers와 동일하나 response에서만 사용되는 header 값들이 있다.
                - 예를 들어, User-Agent 대신에 Server 헤더가 사용된다.

            * Body
                - Response의 body와 일반적으로 동일하다.
                - Request와 마찬가지로 모든 response가 body가 있지는 않다. 데이터를 전송할 필요가 없을경우 body가 비어있게 된다.



            * HTTP Status Code
                            -2xx - 성공
                            -3xx - 리다이랙션 : 클라이엍느가 이전 주소로 데이터를 요청해서 서버에서 새로운 URI로 유도
                            -4xx - 클라이언트 에러 :  유효하지 않은 자원을 요청 ,  권한이 잘못된 경우 발생
                            -5xx - 서버 에러 :  요청한 동작에 대해 서버가 수행할 수 없는 경우, 서버 과부하, 유지 보수



    3 HTTP 와 HTTPS 

        * 세션 계층에서 SSL 프로토콜을 사용하여 보안을 강화한 HTTP 프로토콜 

            - HTTP는 기본적으로 평문 데이터 전송을 원칙으로 하기 때문에 개인의 프라이버시가 오가는 서비스들 (전자상거래, 전자메일, 사내문서)에 사용하기 힘들다

            - SSL은 보안을 위한 세션계층의 프로토콜 

            - HTTP 문서는 SSL 레이어를 통과하면서 암호화 돼서 목적지에 도착하고, 목적지에서는 SSL 레이어를 통과하면서 복호화 돼서 웹 브라우저에 전달된다.

            - SSL은  암호방식중  공개치 암호화 방식을 사용한다  (암호화 방식 : 단방향 암호화, 대칭키 암호화, 공개키 암호화 )

            - HTTPS를 하나의 프로토콜 (x), HTTP와 SSL은 전혀 다른 계층의 프로토콜콜의 조합 (o)


        * HTTP 와 HTTPS 차이점  

            - HTTPS URL은 "https://" 로 시작한다. 기본 포트번호는 443이다. HTTP URL은 "http://" 로 시작한다. 기본 포트번호는 80이다.

            - 일반적으로 HTTPS는 HTTP에 비해서 느리기 때문에 민감한 정보를 다루는 페이지 (로그인 혹은 유저정보)는 HTTPS로 전송하고, 기타 페이지는 HTTP로 전송하는 방법을 사용한다.


        * 참고자료 
          https://velog.io/@teddybearjung/HTTP-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%ED%95%B5%EC%8B%AC-%EC%9A%94%EC%86%8C



    4 HTTP 버전별 특징 

        * HTTP/1.0  (현재 사용안됨)

            - http는 TCP/IP 기반이기 때문에 연결때마다 handshaking 과정을 해야했다  --> 너무나 비효율적 
            - 헤더에  keep-alive 옵션을 추가하여 일정시간 일정 요청시간동안 이전의 TCP 연결을 재 사용하여 연결과정에 드는 시간을 없애는 것 
            - 1.1 부터 Persistent Connection (같은 개념)을 프로토콜의 기본 기능으로 설정하여  keep-alive 옵션을 추가안해도 됨 


        * HTTP/1.1 (현재 사용되기는 함)

            - 기본적으로 Connection당 하나의 요청을 처리
            - 동시전송이 불가능하고 요청과 응답이 순차적
            - HTTP 문서안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비례하여 Latency(대기 시간)이 길어지게 된다.
            - 그래도 1.0으로부터 Persistent Connection 을 개선함 
            
            - connection당 하나의 요청처리를 개선
            
            - pipelining 기법 
                
                - 하나의 Connection을 통해서 다수개의 파일을 요청/응답 받을 수 있는 기법
                - 클라이언트는 각 요청에 대한 응답을 기다리지 않고, 여러개의 HTTP Request 를 하나의 TCP/IP Packet안에 보낸다.
            
            - Head of Line Blocking :  파이프라인 키법으로 한번의 connection에 여러번 요청하여도 순차적으로 완료되어야함. 앞에 하나안되면 나머지도 지연 

            - 이것말고도 다양한 노력들 존재 


        * HTTP/2.0 (대부분 사용함)

            * Multiplexed Streams
            
                - 한 커넥션으로 동시에 여러개의 메세지를 주고 받을 있으며, 응답은 순서에 상관없이 stream으로 주고 받는다.
                - HTTP/1.1의 Connection Keep-Alive, Pipelining의 개선
            
            * Stream Prioritization
                -  리소스간 의존관계(우선순위)를 설정 (먼저 랜더링 해서 생기는 문제점 방지 )


            *  Server Push
                - 서버는 클라이언트의 요청에 대해 요청하지도 않은 리소스를 마음대로 보내줄 수 도 있다.


            * Header Compression
                - HTTP/2는 Header 정보를 압축하기 위해 Header Table과 Huffman Encoding 기법을 사용하여 처리함


        * 참고자료  https://kooku.netlify.app/web/http1.1-vs-http2/










<br/>

### 💡 암호화 방식 

    * 단방향 암호화 : 로그인 

    * 대칭키 암호화 : 대칭키 공유 

    * 공개키 암호화 : 암호키 쌍을 사용하여, 송신자는 수신자의 공개키를 사용해서 암호화하고 
                    수신자는 비밀키를 사용하여  송신자가 보낸 암호문을 복호화한다.









