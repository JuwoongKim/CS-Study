# 22.01.06

---

## 개념 정리 


<br/>

### 💡 데이터 베이스 시스템 

    - 각 조직에서 사용하던 데이터를 모아서 통합하고 서로 공유하여 생기는 장점을 이용하는 시스템

    - 데이터의 검색과 변경 작업을 주로 수행한다. 
    
    - 변경이란 시간에 따라 변하는 데이터 값을 데이터베이스에 반영하기 위해 수행하는 삽입, 삭제, 수정 등의 작업을 말한다. 데이터베이스는 이러한 검색과 변경의 빈도에 따라 시스템 구축의 난이도가 결정된다.


    * 구성요소 

        * 데이터 베이스 

            - 하드디스크에 저장된 데이터

        * DBMS

            - 주기억장치에 저장된 소프트웨어

        * 데이터 모델 

            - 데이터가 저장되는 기법에 관한 개념적인 내용 


<br/>

### 💡 SQL (Structured Query Language)

    - 데이터 베이스에서 사용하는 프로그래밍 언어 

    - DDL, DML, DCL 로 구성됨 

    * 구성요소 

        * SQL은 데이터 정의어(Data Definition Language), 

            - Create, ALter, Drop문과 같이 DBMS에 저장된 데이터 구조를 정하기 위해 

        * 데이터 조작어(Data Manipulation Language), 

            - Select, Insert, Delete, Update 문과 같이 데이터를 검색, 삽입, 삭제, 수정하는 데 사용하는 언어

        * 데이터 제어어(Data Control Language)로 구성

            - Grant, Revoke 문과 같이 데이터의 사용 권한을 관리


    * 내부적 실행순서 
        select              - 5  
        from                - 1
        where             - 2
        group by        - 3
        having            - 4
        order by         - 6


        - from : 여기 적혀있는 테이블이 정말 존재하는 테이블인지 확인하고 select권한이 있는지도 확인합니다. select 권한이 없는데 select문을 날린 경우 db가 뱉는 에러가 semantic error이며 syntax erro는 오타, 쉼표가 있어야 하는 곳에 쉼표가 없는 경우 내뱉는 에러입니다. 그래서 from절을 체크해서 어떤 테이블을 액세스를 해야되는지를 확인합니다.
        
        - where :어떤 조건들이 있는지 확인하고 테이블에서 이 조건에 맞는 로우들을 가져옵니다.
        
        - group by :내가 가져온 로우들을 어떤 방식으로 group by할 것인지 결정합니다.
    
        - having : 내가 가져온 로우들에서 조건을 검사하여 내가 어떤 데이터들을 버려야 하는지 결정합니다.
    
        - select : 내가 가져온 로우중에서 어떤 컬럼들을 출력해야하는지 체크합니다. 여기서 일단 다 가져온 다음에 select하기 때문에 select * from ~한것이랑 select name from ~한 것이랑 사실상 io비용이 같다는 것입니다. 만약 select절에 있는 컬럼들이 모두 인덱스에 담겨 있다면 조금 다른겠지만 이 경우를 제외한 경우라면 드는 io비용은 같습니다.
    
        - order by : 가져온 로우들을 기준에 맞춰 정렬합니다. 여기서 order by절이 select 절보다 더 늦게 수행되기 때문에 만약 select절에서 컬럼에 alias를 지정해놨을 경우에 group by에서 alias를 사용할 수 있습니다. 반면에 group by의 경우 select보다 먼저 수행되기 때문에 alias를 사용할 수 없습니다.



<br/>

### 💡 데이터베이스 사용자

    - 일반 사용자 
        
        : 응용 프로그래머가 작성한 프로그램을 이용하는 사람이다

    - 응용 프로그래머 
        
        : 데이터베이스로 문제를 해결하는 프로그램을 작성하는 사람

    - SQL 사용자 

        : SQL  질의를 작성하거나 SQL로 프로그램을 작성하는 사람

    - 데이터 베이스 관리자(DBA) 

        : 조직의 데이터베이스 운영을 총괄


<br/>

### 💡 DBMS

    - 사용자와 데이터베이스를 연결시켜주는 소프트웨어


    * 구성요소 

        *  DML, DDL Embedded DML컴파일러   
        
            - SQL을 번역
            - 응용 프로그램에 삽입(embedded)된 SQL을 번역

        * 질의처리기 (쿼리 평가 엔진)

            - 번역된 SQL구문 분석
            - 계획을 세우고 실행하는 DBMS의 핵심 기능을 담당하는 모듈 
            - 어떤 순서로 기억장치의 데이터에 접근할지를 결정 ( 결정되는 계획= 실행 계획 )
            - 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 '접근 메서드'라고 부릅니다.


        * 버퍼 매니저
        DBMS는 버퍼라는 메모리 영역을 확보해둡니다. 이 메모리 영역을 관리하는 것이 바로 버퍼 매니저입니다. 버퍼 매니저는 디스크를 관리하는 디스크 용량 매니저와 함께 연동되어 작동합니다.

        * 디스크 용량 매니저
        디스크 용량 매니저는 어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어합니다. 

        * 트랜잭션 매니저와 락 매니저
        수백에서 수천 명의 사람이 동시에 데이터베이스에 접근해서 사용하게 되는데, 이때 각각의 처리는 DBMS의 내부에서 트랜잭션이라는 단위로 관리됩니다. 이러한 트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 것이 트랜잭션 매니저와 락 매니저의 역할입니다.

        * 리커버리 매니저
        DBMS가 저장하고 있는 데이터 중에는 절대 잃어버리면 안 되는 데이터가 있습니다. 장애가 발생했을 때 중요한 데이터는 정기적으로 백업하고, 문제가 일어났을 때 복구를 해줘야합니다. 이 기능을 수행하는 것이 리커버리 매니저입니다. 


        ** DBMS는 아니지만, 데이터베이스 시스템을 구성하는 요소 

            * 데이터 베이스 

            * 인덱스 

                - 데이터베이스의 데이터를 빠르게 접근하기 위해서.

            * 데이터 사전 = 메타데이터 = 카탈로그 


        * 참고자료 
            
            - https://insight-bgh.tistory.com/m/67 


    * 기능 :

        - 데이터 정의(Definition) : 데이터의 구조를 정의하고 데이터 구조에 대한 삭제 및 변경 기능을 수행함
        - 데이터 조작(Manipulation) : 데이터를 조작하는 소프트웨어(응용 프로그램)가 요청하는 데이터의 검색, 삽입, 수정 삭제 작업을 지원함
        - 데이터 추출(Retrieval) : 사용자가 조회하는 데이터 혹은 응용 프로그램의 데이터를 추출함
        - 데이터 제어(Control) : 데이터베이스 사용자를 생성하고 모니터링하며 접근을 제어함 백업과 회복, 동시성 제어 등의 기능을 지원함


        - DBMS는 일관성을 유지하기 위해 무결성 제약조건을 활용함.
        - DBMS는 고립성을 유지하기 위해 동시성 제어 알고리즘을 작동시킴.
        - DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 이용함.




<br/>

### 💡 데이터 모델 


    * 데이터베이스 시스템에서 데이터를 저장하는 이론적인 방법에 관한 것으로, 데이터베이스에 데이터가 어떻게 구조화되어 저장되는지를 결정


    * 데이터 베이스 구조 : 외부 단계, 개념 단계, 내부 단계로 나누어지며 각 단계는 외부 스키마, 개념 스키마, 내부 스키마로 구성

        - 스키마(schema)는 그리스어에서 유래된 단어로 데이터베이스의 조직이나 구조를 의미한다.

        * 외부 스키마 
            - 서브 스키마(sub schema)라고도 하며, 뷰의 개념이다. 개념 스키마 중 사용자에게 필요한 부분 스키마를 의미

            - 뷰 :  select문을 저장한 객체라고 할 수 있습니다. 데이터베이스 존재하는 일종의 가상 테이블을 의미하며 실제 테이블처럼 행과 열을 가지고 있지만, 실제로 데이터를 저장하고 있지는 않습니다. 본래 데이터베이스 객체로 등록할 수 없는 SELECT 명령을 객체로서 이름을 붙여 관리할 수 있도록 한 것이 뷰 입니다. 따라서 뷰를 참조하면 그에 정의된 SELECT명령의 실행결과를 테이블처럼 사용할 수 있습니다.

	    * 개념 스키마  

            - 전체 데이터베이스의 정의를 말하는 것으로 통합 조직별로 하나만 존재한다. 저장 장치에 독립적으로 기술되며, 데이터와 관계(relation), 제약사항, 무결성에 대한 내용이 포함

	    * 내부 스키마  
            - 물리적 저장 장치에서 데이터베이스가 실제로 저장되는 방법의 표현이다. 인덱스, 데이터 레코드의 배치 방법, 데이터 압축 등에 관한 사항이 포함

    * 스키마 특징 

	    -스키마는 데이터의 구조적 특성을 의미한다.
	    -스키마는 데이터 사전(Data Dictionary)에 저장된다.
	    -스키마는 현실 세계의 특정한 한 부분의 표현으로서 특정 데이터 모델을 이용해서 만들어진다.
	    -스키마는 시간에 따라 불변인 특성을 갖는다.

    * 메타 데이터 = 데이터 사전 = 시스템 카탈로그 

	    - 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정보를 유지, 관리하는 시스템
	    - 실제 저장되는 데이터는 아니지만, 저장되는 데이터와 직접 혹은 간접적으로 관계가 있는 정보를 제공하는 데이터



<br/>

### 💡 데이터의 독립성 

    * 3단계 데이터베이스 구조에서 하위 단계의 내용을 추상화하여 상위 단계에 그 세부 사항을 숨김으로써 한 단계 내의 변경에 대해서다른 단계와 상호 간섭이 없도록 하는 것이다.
	
	    * 논리적 데이터 독립성 : 외부 단계와 개념 단계 사이의 독립성으로, 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원한다.
	
        * 물리적 데이터 독립성 : 개념 단계와 내부 단계 사이의 독립성으로, 저장 장치 구조 변경과 같이 내부 스키마가 변경되어도 개념 스키마에 영향을 미치지 않도록 지원한다.



<br/>

### 💡 데이터의 무결성 


	* 의미  
	    - 데이터베이스에 저장된 데이터는 결함이 없어야 하며 질의에 대해 신뢰성 있는 답을 제공해야 한다
	    - 그래서 데이터를 저장하는 데 있어서 데이터베이스는 일관성을 유지하고 중복을 제거하는 등 데이터의 신뢰도를 유지해야 한다.
	    - 따라서 데이터의 삽입, 삭제, 수정 시 여러 가지 제약조건이 따른다. 
	    - 데이터 무결성(integrity)은 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것을 말한다.

	* 무결성을 유기하는 방법 
	    - 일관성과 정확성을 잃어버린 데이터베이스는 정보로서의 가치에 심각한 문제가 있는 것이다
	    - 일관성과 정확성을 가지고 구축된 데이터베이스가 계속해서 무결성을 유지하려면 투플의 삽입, 삭제, 수정 시 데이터의 제약조건 준수 여부를 확인하여야 한다.
	    - 데이터의 삽입, 삭제, 수정 시 필요한 기본적인 제약조건을 DBMS가 알아서 지켜준다면 프로그래머는 데이터 변동에 따른 대응에 필요이상의 시간을 투자하지 않고 프로그래밍에 집중할 수 있고, 소프트웨어의 성능 및 데이터의 신뢰성 향상에도 큰 도움을 줄 수 있다
	    - 통제에 의한 데이터 갱신으로서, 이 방법은 검증 프로그램을 이용하여 모든 갱신 처리 과정에서 반드시 검증 단계를 거치도록 통제를 가한다.


	* 무결성의 종류 
	- 널 무결성 : 릴레이션의 특정속성 값이 Null이 될 수 없도록 하는 규정
	- 고유 무결성 : 릴레이션의 특정 속성에 대해서 각 튜플이 갖는 값들이 서로 달라야 한다는 규정
	- 참조 무결성 : 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다는 규정 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
	- 도메인 무결성 : 특정 속성의 값이, 그 속성이 정의된 도메인에 속한 값이어야 한다는 규정
	- 키 무결성 : 하나의 테이블에는 적어도 하나의 키가 존재해야 한다는 규정



    *  무결성 제약조건 

	    - 제약조건의 준수여부는 데이터의 변경(삽입, 수정, 삭제)이 있을 때마다 확인해야 한다

        * 도메인 무결성 제약조건
            - 투플에 삽입 가능한 데이터의 값을 제한하는

        * 개체 무결성 제약조건 
            -  관계 표현을 위한
            * 릴레이션에서 기본키를 구성하는 속성은 Null값이나 중복값을 가질 수 없다.
        
        * 참조 무결성 제약조건 
            -  관계 표현을 위한	
            * 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.
            - 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다는 것이다. 즉 부모 릴레이션의 도메인과 다른 값으로 삽입, 수정될 때 거부되고, 반대로 자식 릴레이션에서 참조하고 있는 값을 부모 릴레이션에서 삭제하거나 다른 값으로 변경하려고 하면 거부된다


	* 참고자료 : 
	    https://coding-factory.tistory.com/221
	    https://deftkang.tistory.com/52



<br/>

### 💡 키 

        키 

        * 키 (key)
        - 데이터베이스에서 데이터의 사용 및 관계 표현에 가장 중요한 개념
        - 무엇인가를 유일하게 식별한다는 의미
        - 릴레이션에서 특정 투플을 식별할 때 사용하는 속성 혹은 속성의 집합

        * 슈퍼키(super key)
        - 슈퍼키는 투플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합을 말한다. 즉 투플을 식별할 수 있으면 모두 슈퍼키가 될수 있다.


        * 후보키(candidate key)
        - 후보키는 투플을 유일하게 식별할 수 있는 속성의 최소 집합이다. 즉 슈퍼키 중에서 최소의 속성으로 집합된것이 후보키가 된다.


        * 기본키(PK, Primary Key)

            - 기본키는 후보키 중 하나를 선정하여 대표로 삼는 키를 말한다.

            * 기본키 선정시 고려사항
            -릴레이션 내 투플을 식별할 수 있는 고유한 값을 가져야 한다.
            -NULL 값은 허용하지 않는다.
            -키 값의 변동이 일어나지 않아야 한다.
            -최대한 적은 수의 속성을 가진 것이라야 한다.
            - 향후 키를 사용하는 데 있어서 문제 발생 소지가 없어야 한다.


        5. 대리키(surrogate key, artificial key)

            - 기본키가 보안을 요하거나, 여러 개의 속성으로 구성되어 복잡하거나, 마땅한 기본키가 없을 때는 일렬번호 같은 가상의 속성을 만들어 기본키로 삼는 경우가 있다. 이러한 키를 대리키 혹은 인조키라고 한
            - 고객 릴레이션에서 마땅한 기본키가 없어 (고객번호, 도서번호) 와 같이 기본키가 설정 되었을 경우 주문번호 속성을 만들어 줌으로써 주문번호를 기본키로 삼는다.


        6. 대체키(alternate key)
        
            - 대체키는 기본키로 선정되지 않은 후보키를 말한다. 


        7. 외래키(FK, Foreign key)
            
            - 외래키는 다른 릴레이션의 기본키를 참조하는 속성을 말한다. 외래키는 다른 릴레이션의 기본키를 참조하여 관계 데이터 모델의 특징인 릴레이션 간의 관계를 표현한다

        특징 
            -관계 데이터 모델의 릴레이션 간의 관계를 표현한다.
            -다른 릴레이션의 기본키를 참조하는 속성이다.
            -참조하고(외래키) 참조되는(기본키) 양쪽 릴레이션의 도메인은 서로 같아야 한다.
            -참조되는 값이 변경되면 참조하는 값도 변경된다.
            -NULL 값과 중복 값 등이 허용된다.
            -자기 자신의 기본키를 참조하는 외래키도 가능하다.
            -외래키가 기본키의 일부가 될 수 있다


        * 출처: https://deftkang.tistory.com/51?category=1089006 [deftkang의 IT 블로그]



<br/>

### 💡 관게형 데이터 베이스  

    * 릴레이션 
        :  행과 열로 구성된 테이블
        : 릴레이션은 스키마와 인스턴스로 이루어진

    * 릴레이션 스키마 
        : 스키마는 테이블의 첫 행인 헤더에 나타나며 각 데이터의 특징을 나타내는 속성, 자료타입 등의 정보를 담고 있다

        : 속성(attribute) : 릴레이션 스키마의 열 / 도메인(domain) : 속성이 가질 수 있는 값의 집합 / 차수(degree) : 속성의 개수


    * 인스턴스 
        : 인스턴스는 정의된 스키마에 따라 테이블에 실제로 저장되는 데이터의 집합
        ( 튜플, 레코드들의 집합)
            
        : 투플(tuple) : 릴레이션의 행 카디날리티(cardinality) : 투플의 수


    *  출처: https://deftkang.tistory.com/50?category=1089006 [deftkang의 IT 블로그]




<br/>

### 💡 아노말리와 정규화 


    *아노말리 
        
        - 릴레이션에서 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일일치가 발생하는 것을 말합니다.
        - 테이블을 설계할 때 잘못 설계하여 데이터를 삭제,수정,삽입할 때 논리적으로 오류가 생기는 것을 말합니다. 대부분 이상현상이 발생하는 데이터의 중복성때문인데 이를 제거하는 과정이 정규화 입니다.

        * 1. 삽입 이상 : 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상입니다.
            - 강의를 아직 수강하지 않은 새로운 학생을 삽입할 경우 강의코드 속성에는 null값이 들어가야 하는 문제가 생깁니다.

        * 2. 갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 이상입니다.
            - 강의코드가 "AAC3"인 서준호의 전화번호를 수정할 경우, 3번째 튜플의 데이터만 수정될 것입니다. 그러면 3,4번째 튜플은 같은 사용자의 데이터 인데도 불구하고 전화번호가 다르게 됩니다.

        * 3. 삭제 이상 : 어떤 정보를 삭제하면, 유용한 다른 정보까지 삭제되어버리는 이상입니다. 
            - 강의코드가 AAC1인 데이터베이스 개론 강의를 삭제하게 되면 김영호 학생의 데이터까지 삭제되어버립니다.

        * 참고예시 : https://kosaf04pyh.tistory.com/m/294

    
    * 정규화 

        - 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 의미합니다. 
        - 데이터 중복에 의한 이상현상을 해소하는 과정을 의미합니다.
        - 정규화에는 1정규형(1NF), 2정규형(2NF), 3정규형(3NF), BCNF(Boyce-Codd Normal Form), 4정규형(4NF), 5정규화(5NF)가 주로 실무에서 사용


        * 1 정규형(1NF) 
            - 모든 속성을 반드시 하나의 원자값만 가져야 한다

        * 정규형(2NF)  
            - 부분적 함수종속 제거, 모든 속성은 반드시 모든 기본키에 종속되어야 한다(기본키 일부에만 종속되면 안됨)

        * 정규형(3NF) 
            - 이행적 함수종속 제거, 기본키가 아닌 모든 속성간에는 서로 종속될 수 없다
	        - 학생 테이블의 기본키는 학번입니다. 하지만 학과 속성의 경우 학과번호에 종속됩니다. 이처럼 기본키가 아닌 속성들간에는 서로 종속관계가 될 수 없습니다. 이 경우 학과테이블을 따로 만들어 학생테이블에서 학과 테이블을 참조하도록 만들어야 합니다.

        * BCNF : 기본키가 아닌 속성이 기본키의 속성을 결정지을 수 없다.
	    - BCNF : 기본키가 아닌 속성이 기본키의 속성을 결정지을 수 없다.

    *참고예시 : https://kosaf04pyh.tistory.com/m/295
    ( 관련 문제를 직접 풀어보는 것이 좋다고 생각한다.)



<br/>

### 💡 인덱스 

    - 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
    - 데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.


    * 인덱스 자료구조

	* B-tree구조 
	    - B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있다.

        * 특징 : 
        - 검색 속도가 무척 빨라질 수 있다(단, 항상 그런 것은 아님)
        - 그 결과 해당 쿼리의 부하가 줄어들어서, 결국 시스템 전체의 성능이 향상
        - 인덱스가 데이터베이스 공간을 차지해서 추가적인 공간이 필요해지는데 대략 데이터베이스 크기의 10% 추가공간이 필요해짐
        - 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있다
        - 데이터의 변경 작업이 자주 일어날 경우 오히려 성능이 많이 나빠질 수 있다


	* hash 구조 
	- 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.


    * 참고자료 
    https://mangkyu.tistory.com/m/96


    * 클러스터, 비클러스터 

    * 알고리즘 



<br/>

### 💡 트랜젝션

	- DBMS가 데이터베이스를 다룰 때 사용하는 작업의 단위다
	- 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 갖는다
	- DBMS는 트랜잭션이 이러한 성질을 유지할 수 있도록 지원한다. 
	- 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다(all or nothing).
	- START TRANSACTION 문과 COMMIT문을 사용하여 트랜잭션의 시작과 끝을 표시
	- 위와 같이 작성하면 두 SQL 문은 하나의 논리적인 작업의 단위가 된다.
	- DBMS는 이 두 문장이 모두 수행되거나 모두 수행되지 않도록 지원한다.


	- 작업단위로써 트랜젝션을 정의하는 이유 
	* 데이터베이스에서 데이터를 다룰 때 장애가 일어나는 경우가 있다. 트랜잭션은 장애 시 데이터를 복구하는 작업의 단위가 된다.
	* 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 있다. 트랜잭션은 이 작업을 서로 분리하는 단위가 된다. (여러개의 트랜잭션이 실행될때)


	- 트랜젝션의 성질 

	원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야(all or nothing) 한다.
	일관성(Consistency) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
	고립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.
	지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다. 저장된 데이터는 저장 직후 혹은 어느 떄나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 한다.


	DBMS는 일관성을 유지하기 위해 무결성 제약조건을 활용함.
	DBMS는 고립성을 유지하기 위해 동시성 제어 알고리즘을 작동시킴.
	DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 이용함.
	롤백(Rollback): 트랜잭션이 행한 모든 연산을 취소시키거나 트랜잭션을 재시작함.


	트랜잭션은 활동(Active), 부분완료(Partially Committed), 완료(Committed), 실패(Failed), 철회(Aborted)의 5가지 상태를 가지게 됩니다 
	그림자료 : https://mangkyu.tistory.com/m/30



	트랜잭션 중간에 작업이 잘못되면 회복 알고리즘으로 변경한 내용을 취소한다(자의적으로 트랜잭션을 취소하는 명령어 ROLLBACK을 사용하기도 한다). COMMIT과 ROLLBACK 명령어는 트랜잭션 제어 명령어(TCL, Transaction Control Language)라고 한다
	중간 지점에 수정내용을 반영하는 포인트를 만드는데, 이를 SAVEPOINT(저장점)라고 한다. 트랜잭션이 잘못되어 처음부터 다시 실행해야 할 경우 트랜잭션의 처음이 아니라 SAVEPOINT까지 되돌아가면 트랜잭션 전체가 ROLLBACK되는 것을 막을 수 있다. SAVEPOINT는 트랜잭션 안에 여러 개 만들 수 있다. 



<br/>

### 💡 동시성 제어, 회복 


    * 병행제어(=동시성 제어 ) 


	* 병행제어란 여러개의 트랜잭션이 실행될 때 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않고 다른 트랜잭션에 영향을 주지 않으면서 트랜잭션을 제어하는 것을 의미합니다.
	다중 사용자 환경에서 둘 이상의 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근 제어
	다중 사용자 환경을 지원하는 DBMS의 경우, 반드시 지원해야 하는 기능	

	*목적 :  데이터 베이스의 공유와 시스템 활용도의 최대화, 데이터 베이스의 일관성 유지, 사용자에 대한 응답시간을 최소화

	* 트랜잭션이 동시에 실행된다면 (고립성은 상호 간의 트랜잭션을 독립적으로 만들어 주었습니다. 그런데 2개 이상의 트랜잭션이 하나의 값에 접근하는 경우에는 어떻게 될까요?)
	    - Dirty Write : 같은 데이터에 대해 동시에 두 개 이상의 트랜잭션이 값을 바꾸고자 할 때 발생되는 현상
        -Dirty Read : 아직 종료(commit)되지 않은 트랜잭션의 쓰기 내용을 읽는 것으로 비정상적 상태의 데이터를 읽게 되는 현상
        -Non-repeatable Read :어떤 트랜잭션에서 동일한 데이터의 값을 매번 읽을 때 마다 틀려지는 현상
        -Phantom Read :기존 데이터는 동일한 데 새로 추가된 값에 의해 데이터 값이 변경되는 현상


	    - 1개의 트랜잭션은 쓰고 1개의 트랜잭션은 읽는 경우 ( 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 문제 )
	    - 2개의 트랜잭션이 모두 쓰기(Write) 시 무제어 병행 수행을 하는 경우 ( 갱신 손실, 모순성, 연쇄 복귀 )


	* 갱신 손실(Lost Update) ] 
        - 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되는 것을 의미
		- 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생


	* 모순성(Inconsistency) 
        - 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황


	* 연쇄 복귀(Cascading Rollback)  
        - 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생
		- 한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제


		
	* 트랜잭션 스케줄 
	트랜잭션들은 삽입, 수정, 삭제 등과 같은 연산들로 이루어져있는데 여기서 트랜잭션 스케줄이란 그 연산들의 실행 순서를 의미합니다


	1. 직렬 스케줄의 경우에는 트랜잭션의 연산을 모두 순차적으로 실행하는 유형을 의미합니다. 즉, 하나의 트랜잭션이 실행되면 해당 트랜잭션이 완료되어야 다른 트랜잭션이 실행될 수 있습니다. 

	2. 비직렬 스케줄은 트랜잭션의 직렬 수행 순서와 상관없이 병행 수행하는 스케줄을 의미합니다. 그러므로 한 트랜잭션이 진행중인 상황에서 다른 트랜잭션이 실행될 수 있습니다. 

	3. 직렬화 스케줄 :  서로 영향을 주지 않는 직렬 스케줄을 비직렬적으로 수행


	참고자료 : https://mangkyu.tistory.com/m/30


	* 병행 제어 기법 

	    - 로킹(Locking) : 트랜잭션이 어떤 데이터에 접근하고자 할 때 로킹을 수행하며 로킹을 한 트랜잭션만이 로킹을 해제할 수 있음. 로킹되어 있는 데이터에는 다른 트랜잭션이 접근할 수 없음, 트랜잭션은 로킹이 된 데이터에 대해서만 연산을 수행할 수 있으며 로킹의 단위에는 필드, 레코드, 파일, 데이터베이스 모두 로킹이 될 수 있음
		         : 로킹 단위가 크면 : 관리하기가 용이(로킹 오버헤드 감소), 하지만 동시성 수준이 낮아짐, 로킹 단위가 작으면 : 동시성 수준이 높아지지만 관리가 까다로움(로킹 오버헤드 증가)

		- 2단계 로킹 규약 : Lock과 Unlock이 동시에 이루어지면 일관성이 보장되지 않으므로 Lock만 가능한 단계와 Unlock만 가능한 단계를 구분하며 직렬가능성을 보장함, 하지만 교착상태가 발생할 수 있음.
			확장단계 : 트랜잭션이 Lock만 할 수 있고 Unlock은 할 수 없음 ,축소단계 : 트랜잭션이 Unlock만 할 수 있고 Lock은 할 수 없음

	    - 타임스탬프(Time Stamp) : 
		데이터에 접근하는 시간을 미리 정하여 정해진 시간의 순서대로 데이터에 접근하며 수행함, 직렬가능성을 보장하며 시간을 나눠 사용하기 때문에교착상태가 발생하지 않음, 하지만 연쇄복귀를 초래할 수 있음.

	    - 낙관적 병행제어(Optimistic Concurrency Control)
		트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사함, 트랜잭션 수행 동안 그 트랜잭션을 위해 유지되는 데이터 항복의 지역사본에 대해서만 갱신하며 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영함
	
	    -  다중 버전 병행제어(Multi-version Concurrency Control)
		하나의 데이터 아이템에 대해 여러 버전의 값을 유지하며 조회성능을 최대한 유지하기 위한 기법, 트랜잭션 간의 충돌 문제는 대기가 아니라 복귀처리 함으로 연쇄복귀초래 발생 가능성이 있음



    * 장애

        * 장애의 유형 :
            트랜잭션 장애: 트랜잭션의 실행 시 논리적인 오류로 발생할 수 있는 에러 상황
            시스템 장애: H/W 시스템 자체에서 발생할 수 있는 에러 상황
            미디어 장애: 디스크 자체의 손상으로 발생할 수 있는 에러 상황

        *회복(Recovery) 
        데이터베이스를 장애가 발생했던 이전의 상태로 복구시켜서 일관된 데이터베이스 상태를 만드는 것
        데이터베이스를 갱신하는 과정에서 장애가 발생한 경우 회복절차를 수행하여 장애 발생 이전의 데이터베이스로 만드는 것을 회복

        * 방법1 .덤프 : 회복을 위한 데이터 복사본을 만드는 방법 ( 일정 주기로 원본의 데이터베이스의 모든 내용을 다른 저장장치에 복사하는 것)
        * 방법2. 로그(Log)를 이용하는 방법 (  로그는 변경 이전의 데이터베이스를 기준으로 변경 연산이 발생할 때 마다 로그 파일을 작성하여 기록하고, 회복할 때 로그에 적힌 내용을 사용하여 복원하는 방법)




<br/>

### 💡 데이터 베이스 종류 


    * 기존은 관계형 데이터베이스(RDBMS) 로 데이터 베이스 업무를 수행함 
    * SQL 언어로 사용 가능, SQL 데이터베이스

    * 빅데이터: NoSQL 데이터베이스

        특징 
        - Not only SQL
        - RDBMS의 한계를 극복하기 위해 만들어진 새로운 형태의 데이터저장소
        - RDBMS처럼 고정된 스키마 및 JOIN 이 존재하지 않음
        - 스키마 변경? ALERT 등 필요 없음


    * 비교 
        * SQL
        - 정해진 규격 (Schema, Table, Column)
        - Join 가능 
        - 트랜젝션 사용 
        - 분산처리 어려움 

        * NoSQl
        - 정해진 규격 없음 
        - Join 불가능 
        - 트랜젝션 없음  
        - 분산처리 쉬움 

    * NoSql 이 생겨난 까닭

        * RDBMS를 기본으로 사용하지만,초당 데이터가 수십만개씩 쌓이는 서비스가 많아지면서(쇼셜, 온라인 서비스등), NoSQL을 사용하는 경우가 많아지고 있음


        * 경험적 수치

            - 95% read, 5% write 경우는 RDBMS 가 성능이 나쁘지 않음
            - 50% write > 인 경우 RDBMS는 성능 저하 또는 불안정
            - NoSQL + Redis (In memory cache) 등을 고려하게 됨

    * 관계형 데이터베이스 종류
        - MySQL, Oracle, PostgreSQL, SQLlite



    * NoSQL 데이터베이스는 각 데이터베이스마다 기반으로 하는 데이터 모델이 다르므로, 데이터 모델별로 대표적인 데이터베이스를 알아둘 필요가 있음


    * NoSQL 데이터베이스는 각 데이터베이스마다 기반으로 하는 데이터 모델이 다르므로, 데이터 모델별로 대표적인 데이터베이스를 알아둘 필요가 있음, 각기 데이터베이스 다루는 인터페이스가 다름

    * Key/Value Store

        - redis

    * Wide Column Store

        - h-base , cassandra

    * Document Store

        - mongo DB

    * Graph Store

        - New4j


    * MongoDB 

        - SON 기반의 Document 기반 데이터 관리
