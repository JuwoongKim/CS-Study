# Database 02. transaction

## 00. transaction

- ### 개념

  데이터베이스의 상태를 변화시키기 위해 수행하는 논리적인 작업의 단위이다.(질의어를 통해 db에 접근하는 것)

  RDBMS는 트랜잭션 기능을 보장하기 위해 4가지 성질을 가진다.

  - Atomicity

    트랜잭션이 db에 모두 반영되거나 아니면 모두 반영되지 않는 성질이다.

  - Consistency

    트랜잭션의 작업 처리 결과가 항상 일관성이 있어야한다.

  - Isolation

    둘 이상의 트랜잭션이 수행 중일 때 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다.

  - Durability

    트랜잭션이 성공적으로 완료되었을 경우 결과는 영구적이어야 한다.

---

<br/>

## 01. Concurrency Control

- ### 개념

  서로 다른 트랜잭션들이 동시에 실행될 경우 트랜잭션 사이의 간섭으로 문제가 발생할 수 있다. 이를 해결하기 위해 동시성 제어 기법이 필요하다.

- 문제 예시

  1. RR(read-read)

     서로 같은 값을 읽기만 한다면 문제가 생기지 않는다. 병행 접근이 가능하다.

  2. WR, RW(write-read, read-write)

     - 오손 읽기 <br />
       읽기 작업을 하는 T1이 X를 읽을 때, 쓰기 작업을 하는 T2가 작업을 철회할 수 있다. 이 때 만약 T1이 T2가 갱신한 데이터를 읽는다면 T1은 결국 무효화된 데이터를 읽는 것이고 이는 오류이다.

     - 반복 불가능 읽기 <br />
       T1이 X를 읽을 때 T2가 중간에 X의 값을 갱신할 수도 있다. 이때 T1이 다시 X를 읽는다면 그때 X는 T2가 갱신한 값이므로 X가 달라지게 된다.

     - 유령 데이터 읽기 <br />
       T1이 X를 읽을 때 T2가 X에 다른 값을 추가할 수 있다. 이때 T1이 다시 한번 X를 읽는다면 전과는 다른 새로운 데이터가 추가되어 나타난다.

  3. WW (write-write)

     - 연쇄 롤백
       T1이 롤백되는데 중간에 같은 값에 접근한 T2가 commit 되었다면 T2까지 롤백해야한다. 하지만 지속성을 보장하는 트랜잭션의 조건 때문에 T2는 롤백될 수 없다.

     - 갱신 분실
       트랜잭션이 동시에 같은 데이터에 쓰기 작업을 할 때 늦게 commit된 트랜잭션이 이미 commit된 다른 트랜잭션의 값을 덮어쓸 수도 있다.

---

<br />

## 02. Locking

- ### 개념

  위와 같은 문제들을 해결하기 위해 Locking이 도입되었다. Locking은 트랜잭션들이 동일한 데이터에 병행접근을 하지 못하도록 제어하는 기법이다.

- ### S-lock, X-lock(shared, exclusive)

  S-lock(공유잠금)을 설정한 트랜잭션은 해당 데이터에 읽기 작업만 가능하다. 이 때 다른 트랜잭션에서도 해당 데이터에 S-lock을 설정할 수 있고, 다만 다른 트랜잭션이 쓰기를 위해 X-lock을 설정하려고 한다면 그것을 제어한다.

  X-lock은 해당 데이터에 다른 트랜잭션이 S-lock, X-lock을 설정하는 것을 모두 금지한다.

  - ### 잠금의 한계
    항상 직렬 가능한 스케쥴이 보장되지 않고 Deadlock이 발생할 수 있다. 이를 해결하기 위해 2-Phase-Locking 기법이 나왔지만 이는 여전히 DeadLock 상태를 유발할 수 있기 때문에 이를 해결해야 한다.
    <p align="center"><img src="https://miro.medium.com/max/875/1*jc_FYu7UHIqK-qjpMUa4gg.png" /></p>

---

<br />

## 03. 2PL

확장 단계: 트랜잭션이 lock은 설정할 수 있지만 unlock은 불가능한 단계

축소 단계: 트랜잭션이 unlock은 가능하지만 새로운 lock은 획득 불가능한 단계

모든 lock 연산들은 unlock보다 먼저 실행되어야 한다.

  <p align="center"><img src="https://miro.medium.com/max/875/1*StVsQ4erIFszl37zwA3fyw.png" /></p>

위 그림은 2PL을 준수한 직렬 가능한 스케쥴이다. 하지만 오른쪽 그림에서는 교착상태가 생기는데 이는 2PL의 문제이다.

이를 해결하기 위해서 트랜잭션이 실행될 때 필요한 lock을 한번에 설정하기, 교착상태 회피, 교착상태 탐지 방법 등을 사용해야한다.

또한 마찬가지로 2PL은 연쇄 복귀 문제도 발생할 수 있다.

- ### Strict 2PL
  모든 X-lock은 트랜잭션이 끝날 때까지 unlock되지 않아야 한다.
  -> 연쇄 복귀 문제 해결
- ### Rigorous 2PL
  모든 lock들은 트랜잭션이 끝날 때까지 unlock되지 않아야 한다.
  -> 모두 직렬화 됨
