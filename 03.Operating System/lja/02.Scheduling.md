# Operating System 02. Scheduling

## 00. Schecduling

- ### 개념

  하나의 프로세스의 작업이 끝나고 다음 프로세스를 결정하기 위한 작업

  시스템 성능은 응답시간, 작업 처리량, 자원 활용도에 따라 결정된다. 시스템 성능을 향상시키기 위해 스케줄러가 사용된다.

- ### 선점형

  프로세스의 작업이 마무리되거나 I/O 또는 인터럽트가 발생하지 않았지만 다른프로세스가 CPU를 강제로 점유할 수 있는 방식

- ### 비 선점형
  I/O 또는 프로세스가 종료될 때까지 점유한 프로세스가 CPU를 사용하는 방식

---

<br />

## 01. 스케줄링 단계

1. 작업 스케줄러(장기)
   디스크의 프로그램에서 프로세스화 할 작업을 결정하는 단계. 시분할 시스템에서는 바로 메모리에 올라오기 때문에 중요도가 덜하다.

   승인된 프로세스는 레디 큐에 들어간다.

2. 중기 스케줄러
   너무 많은 프로세스가 메모리에 올라오게 되면 시스템의 성능이 저하된다. 중기 스케줄러는 현재 메모리에 올라와있는 프로세스 중 일부로부터 메모리를 회수하고 디스크의 Swap 공간에 해당 내용들을 저장해둔다.

3. 단기 스케줄러
   어떤 프로세스에게 CPU를 할당해 줄 것인지 결정한다. 미리 설정된 스케줄링 알고리즘에 따라 프로세스를 CPU에 할당한다.

---

<br />

## 02. 스케줄링 기법

### 1. FIFO

    레디 큐에 들어온 순서대로 프로세스에게 CPU를 할당하는 방식이다. 비선점 스케줄링 기법, 작업의 중요도를 고려하지 못한다.

### 2. Priority 스케줄링

    각 작업마다 우선순위를 두는 기법, 우선순위가 낮은 작업들은 무기한 대기 상태(starvation)에 빠질 수 있다.
    -> Aging 기법으로 해결

### 3. RR(round-robin)

    FIFO를 선점형으로 구현한 방식이다. 각 프로세스는 레디 큐에 들어온 순서대로 CPU를 할당 받지만, 설정된 Time quantum 만큼만 CPU를 사용할 수 있다.

    시간이 초과되면 레디 큐의 끝으로 들어간다.

    응답시간이 빠르다.

### 4. SJF

    처리할 작업 시간이 빠른 순서대로 CPU를 할당하는 기법이다. 평균 대기시간이 최적인 알고리즘이지만 각 프로세스의 처리 시간을 미리 알 수 없다.

### 5. SRT

    현재 작업 중인 프로세스를 포함하여 레디 큐에 있는 프로세스들 중 남은 작업시간이 가장 짧은 것에게 CPU를 할당한다.

    실행 시간 추적 overhead 발생
