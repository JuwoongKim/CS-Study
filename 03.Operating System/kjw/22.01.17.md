# 22.01.13

---

## 개념 정리 


<br/>

### 💡 메모리 관리 기법 



    * Swapping  (1단계)

        - 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억장치로 내보내고, 다른 프로세스를 주기억장치로 불러오는 기법 

        - swap - in  : 주기억장치로 불러오는 과정 
        - swap - out : 보조기억장치로 내보내는 과정 

        - 메모리 공간이 부족할때 swapping 을 시작한다.



    * 페이징  (2단계 : 메모리가 연속적으로 할당되야한다는 한계를 해결)

        - 프로세스가 상요하는 메모리 공간이 연속적이어야한다는 제약을 없애는 방법 

        - Frame : 물리 메모리 고정 크기 단위  
        
        - Page : 프로세스가 점유하는 논리적인 메모리 고정 크기 단위 
                 ( 논리적 - 프로그램 동작을 위한 주소 ) 

        - 프로세스가 사용하는 메모리 공간을 페이지 단위로 나누어서 관리되며 개별 페이지는 순서에 상관없이 메모리 프레임에 mapping  되어 관리된다.

        * 효과 

            - 프로세스가 연속적으로 메모리를 할당 받을 필요가 없다.

            - 고정된 블록 단위로 비연속적인 메모리 할당 방법이 가능하기 때문에 외부단편화를 줄일 수 있지만, 외부 단편화는 해결하지 못한다.


    * 세그멘테이션 (2단계 : 메모리가 연속적으로 할당되야한다는 한계를 해결)

        - Page 와 Frame의 크기가 같지 않다  ( unlike - 페이징 ) 

        - 세그먼트 테이블로 관리  
        
        - 세그먼트 번호마다, 세그먼트의 시작물리주소와 한계를 저장 

            한계 ( 세그먼트의 길이 )

        * 효과 

            결국에는 외부 단편화가 생긴다.



    * 가상 메모리 

        - 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법 

        - 프로세스의 필요한 부분만 올라오기 때문에 프로그램이 물리적 메모리보다 커도 가능함 

        - 대게 페이지 단위로 pager에 의해 관리 된다.

        - 실행에 필요한 페이지들만 메모리에 읽어 오면서, 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있다.


        * 요구 페이징 (demand paging) ( 가상 메모리 관련 )

            - 프로그램 시작시, 전체를 메모리에 적재하지 않고, 초기에 필요한 것만 적제하는 전략 



        * 페이지 교체 

            - 필요한 페이지가 메모리로 올라오지 않아서 요청시 page fault 
            (페이지 부재)가 나왔을 시, 보조 기억장치에서 가져오면 된다.
            그러나 메모리가 모두 사용되면 페에지 교체가 이루어진다.

            * 교체 방법 

                - 디스크에서 필요한 페이지 위치 찾기 

                - 빈 페이지 프레임을 찾는다  
                  (없다면 victim 페이지를 고르고, 교체) 

                - 기록하고 관련 테이블 수정 

        
        * 페이지 교체 알고리즘 

            * FIFO 페이지 교체
             
                - 먼저 물리 메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것

                - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 내 부재율을 높이는 부작용을 초래할 수 있다. (belady 모순 )

                - belady 모순 : 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재


            * LRU 페이지 교체 (LRU Page Replacement)

                - LRU: Least Replacemently Used

                - 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

            * LFU 페이지 교체 (LFU Page Replacement)

                - LFU: Least Frequently Used

                - 참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정에서 만들어진 알고리즘


            * 최적 페이지 교체 (Optimal Page Replacement)

                - 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하는 것

                - 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문에 구현 상 어려움이 있다.



        * 가상 주소공간 

            - 프로그램의 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간 


        


        * 효과 

            - 더 많은 프로그램을 메모리에 올려서 동시에 처리할 수 있다. 이에 따라서 응답 시간은 유지되고 , CPU 이용률과 처리율이 높아진다.

            * 프로세스간의 페이지 공유 

                - 시스템 라이브러리는 실제로 물리적 메모리에 하나만 존재하지만, 여거래의 프로세스들은 이러한 공유 라이브러리를 자신의 주소 공간에 두고 상요하는 것처럼 인식한다.

                - 이를 통해 메모리 공유가 가능하고, 공유 메모리로 통신할 수 있다.

                - ex) fork를 통하 프로세스 생성과정에서 페이지 공유 가능 




    * 캐시의 지역성 원리 

        - 캐시란 : 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리

        - CPU가 어떤 데이터를 원하는지를 어느정도 예측할 수 있어야 한다

        - 적중률(Hit rate)을 극대화시키기 위해 데이터 지역성(Locality)의 원리를 사용

        * 지역성의 원리 

            - 전제 조건 : 프로그램은 모든 코드나 데이터를 균등하게 Access하지 않는다는 특성을 기본으로 한다.

            - Locality : 기억장치 내의 정보를 균일하게 Access하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것

            * 시간 지역성(Temporal Locality) 
            
                - 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성

            * 공간 지역성(Spatial Locality)

                - 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성



    * 메모리 관리 관련 용어  


        * 단편화 현상 

            - 사용가능한 메모리가 충분하지만, 작게 나뉘어져있어서 프로세스에게  할당하지 못하는 현상 
    
            - 내부 단편화 : 할당 받은 메모리와 프로세스 사이에서 남는 공간이 생기는 것 

            - 외부 단편화 : 메모리 전체에서 사용하지 못하게 되는 공간 

        * 압축 

            - 단편화를 해결하기 위한 하나의 방법 

            - 프로세스가 사용하는 메모리영역을 한공간으로 몰고, 공간을 확보하는 방법 

            - 매우 비효율적 
            

        * 요구 페이징 (demand paging) ( 가상 메모리 관련 )

            - 프로그램 시작시, 전체를 메모리에 적재하지 않고, 초기에 필요한 것만 적제하는 전략 


        * 교착상태 

            - 둘 이상의 프로세스가 서로  상대방이 원하는 자원을 공유한 상태에서 상대방의 자원을 요구하여 서로 기다리는 현상 

        * 기아상태 

            - 스케줄링에서 우선운위에서 밀려나 cpu및 컴퓨터 자원을 할당받지 못하고 동작하지 못하는 상황  

        * 에이징 

            - 운영체제가 프로세스를 스케줄링 하는 과정에서 프로세스의 대기시간을 우선순위 선정에 비례하게 적용하기 위한 방법 

            - Priority 스케줄링에서 기아 상태 및 무한정 대기를 에이징으로 해결할 수 있습니다.





